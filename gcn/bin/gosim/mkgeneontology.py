#
# COPYRIGHT (C) 2012-2013 TCS Ltd
#
"""
.. module:: mkgeneontology
    :platform: Unix, Windows, MacOSX
    :synopsis: Script to build a refgene sqlite database.

.. moduleauthor:: changjin hong (changjin.hong@gmail.com)

Script to build a geneontology sqlite database. To use this script

usage: mkgeneontology.py [-h] [-i INNAME] [-o OUTNAME] [--force]

Create a GO sqlite database

optional arguments:
  -h, --help            show this help message and exit
  -i INNAME, --input INNAME
                        Name of gene ontology similarity tab delimited file generated by gossto 
  -o OUTNAME, --output OUTNAME
                        Name of sqlite database to create
  --force               Create new database even if the existing one is newer
                        than the *inname*

**NOTE**: Any existing database with the specified outname will be overwritten.
To be safe one should write the new database to a temporary file which, upon
successful completion, can be renamed to the desired database name.


The created database has four tables, called *refgene*, *exons*, *defect*,
*release_info*.
The *refgene* table contains the following columns which are all of type text
unless otherwise indicated.

    - name :        Gene name. Usually starts with NM_ or NR_
    - chrom:        Chromosome on which the gene is present (e.g chr1, chr2)
    - strand:       '+' or '-' depending on which strand the gene is
    - txStart:      Starting position of the transcript (integer)
    - txEnd:        Ending position of the transcript (integer)
    - cdsStart:     Coding region start position (integer)
    - cdsEnd:       Coding region end position (integer)
    - exonCount:    Number of exons in the transcript (integer)
    - score:        An integer of unknown meaning (integer)
    - name2:        Alternative name for the gene
    - cdsStartStat: An enum from one of ('none','unk','incmpl','cmpl')
    - cdsEndStat:   An enum from one of ('none','unk','incmpl','cmpl')
    - error:    Error flag. Values are 0 or 1. This flag denotes 0 if the CDS
                derived from gene definition is multiple of 3 else 1

The *exons* table contains the following columns

    - name:         Gene name. Usually starts with NM_ or NR_
    - number:       The numerical id of the exon, first exon is 1, second is
                    2 and so on (integer)
    - chrom:        Chromosome on which the exon is present (e.g chr1, chr2)
    - start:        Starting position of the exon (integer)
    - end:          Ending position of the exon (integer)
    - frame:        The frame of this exon, 0, 1, 2 or -1 (integer)

The *defect* table contains the following columns

    - gid:    Unique identifier for the entry in refgene table
    - name:   Gene name. Usually starts with NM_ or NR_
    - remark:    Type of defect found in the transcript of the gene.
                 For Eg. CDS not multiple of 3 etc

The *release_info* table contains the following columns

    - file_name:    File Name
    - file_date:    The date when the file was downloaded from website
    - version:    Version Number
    - entry_count:    Number of entries in the refgene table of sqlite DB

The input file for the program is available from the UCSC [1] site

.. [1] ftp://hgdownload.cse.ucsc.edu/goldenPath/hg19/database/refGene.txt.gz
"""

from gcn.etc import dbconfig, fileconfig
from gcn.lib.utils import lib_utils, fileutils
from gcn.lib.io import anyopen, db
from collections import namedtuple
import csv
import argparse
import sys
import os
from datetime import datetime as dt
import time

SCHEMA = ["""create table funsim
                (idx integer PRIMARY KEY AUTOINCREMENT,
                 gene1 text not null,
                 gene2 text not null,
                 score float not null,
                 denominator integer not null,
                 method_id integer not null)
            """,
            """create index funsim_idx1 on funsim (gene1,gene2,score)""",
            """create index funsim_idx2 on funsim (gene2,gene1,score)""",
            """create table uniprot_to_refgene
                (idx integer PRIMARY KEY AUTOINCREMENT,
                 uniprot text not null,
                 gene text not null)
            """,
            """create index uniprot_to_refgene_idx1 on uniprot_to_refgene (uniprot,gene)""",
            """create table go_method
                (idx integer PRIMARY KEY AUTOINCREMENT,
                 method_id integer not null,
                 obo_file text not null,
                 goa_file text not null,
                 method_desc text)
            """
            ]

class GeneOntologyDB(db.DB):
	def createdb(self, inname, goaname, outname, force):
		'''
		Args:
			-inname (str): Name of gene ontology similarity tab delimited file generated by app_build_go.py
			-outname (str): Name of sqlite3 database
			-force (bool): If True overwrite existing database even if it is newer than *ism_prefix
		'''
		
		if os.path.exists(outname):
			#TODO: to handle more than two files or pick one of them
			newer = fileutils.file_newer(inname, outname)
		else:
			newer = True
		self.logger = fileconfig.getlogger()
		
		if not newer and not force:
			self.logger.info('Not Updating. GO database already update')
		else:
			self.inname = inname
			self.goaname = goaname
			self.outname = outname
			self.uni2gene = {}

			t1 = time.time()
			
			# preprocessing (filtering and sorting)
			self._preproces()
			
			# -----------
			self._makedb()
			# -----------
			
			time_taken = (time.time() - t1) / 60
			self.logger.info("Time Taken for creating %s is %f min" % (self.outname, time_taken))
		return
	
	def _preproces(self,min_go_score = 0.5):
		
		#to get temp dir
		tmpD = os.path.join(os.path.dirname(self.inname),'tmp')
		if not os.path.exists(tmpD):
			os.makedirs(tmpD)
		
		self.uniprot_to_gene()
		
		inname_g = self.inname+'.gene'
		fp2 = open(inname_g,'w')
		
		#convert uniprot to hgnc
		for entry in self._iterfile(): #uniprot1, uniprot2, score=(BP+MF+CC)/3, denominator (1<=x<=3)
			if float(entry.score)>=min_go_score:
				gene1=self.uni2gene[entry.prod1]
				gene2=self.uni2gene[entry.prod2]
				fp2.write('%s\t%s\t%s\n'%('\t'.join(sorted([gene1,gene2])),\
					entry.score,entry.denominator))
		fp2.close()
		
		#sorting
		inname_gso = inname_g+'.so'
		lib_utils.sort_tsv_by_col2(inname_g,[1,2,3],['V','V','g'],False,inname_gso,tmpD) #temp dir

		#take max funSim for each pair
		fp = open(inname_gso,'r')
		j=fp.next().strip().split('\t')
		prev_pair = '%s\t%s'%(j[0],j[1])
		mx_score1 = 0.; mx_denom1 = 0
		mx_score2 = 0.; mx_denom2 = 0
		fp.close()
		
		self.inname = inname_gso
		fp2 = open(inname_g,'w')
		for entry in self._iterfile():
			pair = '%s\t%s'%(entry.prod1,entry.prod2)
			if pair != prev_pair: #wraup prev
				if mx_denom2>0:
					fp2.write('%s\t%g\t%d\n'%(prev_pair,mx_score2,mx_denom2))
				elif mx_denom1>0:
					fp2.write('%s\t%g\t%d\n'%(prev_pair,mx_score1,mx_denom1))
				prev_pair = pair
				mx_score1 = 0.; mx_denom1 = 0
				mx_score2 = 0.; mx_denom2 = 0
			
			score = float(entry.score)
			denominator = int(entry.denominator)
			if denominator>1:
				if score>mx_score2:
					mx_score2 = score
					mx_denom2 = denominator
			else:
				if score>mx_score1:
					mx_score1 = score
					mx_denom1 = denominator
		
		#don't forget the last entries
		if mx_denom2>0:
			fp2.write('%s\t%g\t%d\n'%(prev_pair,mx_score2,mx_denom2))
		elif mx_denom1>0:
			fp2.write('%s\t%g\t%d\n'%(prev_pair,mx_score1,mx_denom1))
			
		fp2.close()
		self.inname = inname_g
		os.unlink(inname_gso)
		os.system('rm -rf %s'%tmpD)

	def _extract_go_method(self):
		fp = anyopen.openfile(self.inname)
		method_id, obo_file, goa_file, method_desc = fp.next()[1:].rstrip().split('\t')
		val_field = ','.join(['?']*5)
		gominsert = 'insert into go_method values (%s)'%val_field
		self.curs.execute(gominsert)
		fp.close()
	
	def uniprot_to_gene(self):
		
		self.logger.info('Having a dictionary of mapping uniprot to refGene...')
		pairs = {}
		stream = anyopen.openfile(self.goaname)
		for rec in csv.reader(stream, delimiter='\t'):
			if rec[0][0]=='!':
				continue
			else:
				pair = '%s:%s'%(rec[1],rec[2]) #uniprot,refGene
				if pair in pairs:
					continue
				else:
					pairs[pair]=True
					self.uni2gene[rec[1]]=rec[2]
		stream.close()
		pairs = None
		
	def _makedb(self):
		self.logger.info('Creating FUNSIM database ...')
		self.logger.info('Input files: %s' % self.inname)
		if not os.path.exists(self.inname):
			self.logger.error('%s: No such file' % self.inname)
			self.logger.error('Database not created')
			sys.exit(1)
		self.load(db=self.outname)

		for s in SCHEMA:
			self.createtable(s, True)

		self.curs = self.conn.cursor()

		entry_cnt = 0
		
		#extract gene ontology method from innmae header

		n = 0
		buffer2 = 7000000
		val_field = ','.join(['?']*5)
		goinsert = 'insert into funsim values (%s)'%val_field
		entries = []
		method_id = 1
		
		for entry in self._iterfile(): #uniprot1, uniprot2, score(BP+MF+CC/3), denominator
		
			entries.append((entry.prod1, entry.prod2, entry.score, entry.denominator, method_id))
			n += 1
			if n > buffer2:
				entry_cnt += buffer2
				self.curs.executemany(goinsert, entries)
				n = 0
				entries = []
				print 'importing %d row'%entry_cnt

		if entries:
			entry_cnt += len(entries)
			self.curs.executemany(goinsert, entries)
			print 'importing %d row'%entry_cnt
		print 'done.'
		self.conn.commit()

		#Add GOA
		self._register_goa()

		# Add version details
		fd = dt.fromtimestamp(os.path.getmtime(self.inname)).strftime('%Y-%m-%d')
		version = "v%s_%s" % tuple(fd.split('-')[:2])
		self.set_version('funsim', fd, version, entry_cnt)
		
		self.curs.close()
		self.conn.close()
		self.logger.info('... GO database created')
	
	def _register_goa(self):
		
		self.logger.info('Importing map of uniprot to refGene ...')
		self.logger.info('Input files: %s' % self.goaname)
		
		stream = anyopen.openfile(self.goaname)
		pairs = {}
		
		n = 0
		entries = []
		entry_cnt = 0
		buffer2 = 7000000
		val_field = ','.join(['?']*2)
		goinsert = 'insert into uniprot_to_refgene values (%s)'%val_field
		
		for rec in csv.reader(stream, delimiter='\t'):
			if rec[0][0]=='!':
				continue
			else:
				pair = '%s:%s'%(rec[1],rec[2])
				if pair in pairs:
					continue
				else:
					pairs[pair]=True
					entries.append((rec[1],rec[2]))
					n += 1
					if n > buffer2:
						entry_cnt += buffer2
						self.curs.executemany(goinsert, entries)
						n = 0
						entries = []
						print 'importing %d row'%entry_cnt

		if entries:
			entry_cnt += len(entries)
			self.curs.executemany(goinsert, entries)
			print 'importing %d row'%entry_cnt
			
		self.conn.commit()
		print 'done.'
		pairs = None
		stream.close()
		
	def _iterfile(self):
		"""Internal method. Do not use"""
		fields = 'prod1 prod2 score denominator'.split()

		funsim = namedtuple('funsim', fields)
		stream = anyopen.openfile(self.inname)
		#stream.next()
		for rec in csv.reader(stream, delimiter='\t'):
			#if rec[0][0]!='#':
			yield funsim._make(rec)
		stream.close()
		
def main():
	"""Main script to create the FUNSIM (geneontology) database"""

	infile = fileconfig.FILECONFIG['FUNSIM']
	goa_file = fileconfig.FILECONFIG['GOA']
	outfil = dbconfig.DBCONFIG['GENEONTOLOGY']['name']
	desc = 'Create a GENEONTOLOGY sqlite database'
	parser = argparse.ArgumentParser(description=desc)
	parser.add_argument('-i', '--input', dest='inname', type=str, default=infile, help='Geneontology (Semantic) Similarity File generated by app_build_go.py [funsim]')
	parser.add_argument('-g', '--goa', dest='goaname', type=str, default=goa_file, help='Geneontolgy Annotation File used in generating the semantic ontology scores')
	parser.add_argument('-o', '--output', dest='outname', type=str, default=outfil, help='Name of sqlite database to create')
	parser.add_argument('--force', action='store_true', help='Create new database even if the existing one is newer than *inname*')
	
	args = parser.parse_args()

	GeneOntologyDB().createdb(args.inname, args.goaname, args.outname, args.force)
	sys.exit(0)

if __name__ == "__main__":
	main()
